---
import '../styles/global.css'
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Geist:wght@100;200;300;400;500;600;700;800;900&family=Geist+Mono:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
		<title>BrainRoad Labs</title>
	</head>
	<body>
		<!-- Splash Screen -->
		<div id="br_splash" class="br_splash">
			<div class="br_splash_content">BR</div>
		</div>
		<div class="gradient-bg">
			<svg xmlns="http://www.w3.org/2000/svg">
				<defs>
					<filter id="goo">
						<feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
						<feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -8" result="goo" />
						<feBlend in="SourceGraphic" in2="goo" />
					</filter>
				</defs>
			</svg>
			<div class="gradients-container">
				<div class="g1"></div>
				<div class="g2"></div>
				<div class="g3"></div>
				<div class="g4"></div>
				<div class="g5"></div>
				<div class="interactive"></div>
			</div>
		</div>
		<div class="content-wrapper min-h-screen p-[10px]">
			<slot />
		</div>
		<script src="../scripts/index.js"></script>
		
		<!-- TODO: remove - Navigation Menu -->
		<div class="fixed bottom-20 left-0 right-0 flex justify-center items-center gap-4 z-[9999]">
			<nav class="bg-white rounded-full shadow-md p-2 px-4">
				<ul class="flex gap-5">
					<li><a href="#" id="nav-home" class="hover:text-blue-600 font-medium">Home</a></li>
					<li><a href="#" id="nav-projects" class="hover:text-blue-600 font-medium">Projects</a></li>
					<li><a href="#" id="nav-contact" class="hover:text-blue-600 font-medium">Contact</a></li>
					<li><a href="#" id="nav-explanation" class="hover:text-blue-600 font-medium">Explanation</a></li>
				</ul>
			</nav>
		</div>
		
		<!-- TODO: remove - Controls -->
		<div class="fixed bottom-5 right-5 flex gap-2 z-[9999]">
			<button id="decrementOrder" class="bg-white p-2 rounded-full shadow-md hover:bg-gray-100">
				<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
					<path d="m18 15-6-6-6 6"/>
				</svg>
			</button>
			<button id="incrementOrder" class="bg-white p-2 rounded-full shadow-md hover:bg-gray-100">
				<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
					<path d="m6 9 6 6 6-6"/>
				</svg>
			</button>
		</div>
		
		<script is:inline>
			// TODO: remove
			window.addEventListener('load', () => {
				console.log("Adding button handlers...");
				
				const decrementBtn = document.getElementById('decrementOrder');
				const incrementBtn = document.getElementById('incrementOrder');
				
				if (!decrementBtn || !incrementBtn) {
					console.error("Buttons not found!");
					return;
				}
				
				console.log("Buttons found, adding click handlers");
				
				decrementBtn.onclick = function() {
					console.log("Decrement clicked");
					const containers = document.querySelectorAll('.br_container');
					
					// Get max blocks count (limiting factor for order values)
					const maxBlocks = containers.length;
					
					// Define minimum limit (one less than max blocks)
					const minLimit = -(maxBlocks - 1);
					
					// Check if any container is already at the minimum limit
					let atMinimumLimit = false;
					containers.forEach(container => {
						const orderValue = container.style.getPropertyValue('--order');
						if (orderValue && parseInt(orderValue) === minLimit) {
							atMinimumLimit = true;
						}
					});
					
					// If at limit, show message and stop
					if (atMinimumLimit) {
						console.log(`Cannot decrement: A container is already at minimum value (${minLimit})`);
						return;
					}
					
					// Proceed with decrementing all containers
					containers.forEach(container => {
						// Get current order (as string or number)
						let order = container.style.getPropertyValue('--order');
						
						// If empty, try to get from data-order attribute
						if (!order) {
							order = container.getAttribute('data-order') || '0';
						}
						
						// Convert to number
						let currentOrder = parseInt(order);
						
						// Skip zero when decrementing
						let newOrder;
						if (currentOrder === 1) {
							newOrder = -1; // Skip zero when going from 1 to negative
						} else {
							newOrder = currentOrder - 1;
						}
						
						// Update order value
						container.style.setProperty('--order', newOrder);
						
						// Update classes based on order sign
						if (currentOrder > 0 && newOrder < 0) {
							// Going from positive to negative: add above class, remove default
							container.classList.remove('br_container--default-state');
							container.classList.add('br_container--above');
							console.log(`Changed class: default -> above (${currentOrder} -> ${newOrder})`);
						} else if (currentOrder < 0 && newOrder > 0) {
							// Going from negative to positive: add default class, remove above
							container.classList.add('br_container--default-state');
							container.classList.remove('br_container--above');
							console.log(`Changed class: above -> default (${currentOrder} -> ${newOrder})`);
						}
						
						console.log(`Changed order: ${currentOrder} -> ${newOrder}`);
					});
				};
				
				incrementBtn.onclick = function() {
					console.log("Increment clicked");
					const containers = document.querySelectorAll('.br_container');
					
					// Get max blocks count (limiting factor for order values)
					const maxBlocks = containers.length;
					
					// Check if any container is already at the maximum limit
					let atMaximumLimit = false;
					containers.forEach(container => {
						const orderValue = container.style.getPropertyValue('--order');
						if (orderValue && parseInt(orderValue) === maxBlocks) {
							atMaximumLimit = true;
						}
					});
					
					// If at limit, show message and stop
					if (atMaximumLimit) {
						console.log(`Cannot increment: A container is already at maximum value (${maxBlocks})`);
						return;
					}
					
					// Proceed with incrementing all containers
					containers.forEach(container => {
						// Get current order (as string or number)
						let order = container.style.getPropertyValue('--order');
						
						// If empty, try to get from data-order attribute
						if (!order) {
							order = container.getAttribute('data-order') || '0';
						}
						
						// Convert to number
						let currentOrder = parseInt(order);
						
						// Skip zero when incrementing
						let newOrder;
						if (currentOrder === -1) {
							newOrder = 1; // Skip zero when going from negative to positive
						} else {
							newOrder = currentOrder + 1;
						}
						
						// Update order value
						container.style.setProperty('--order', newOrder);
						
						// Update classes based on order sign
						if (currentOrder > 0 && newOrder < 0) {
							// Going from positive to negative: add above class, remove default
							container.classList.remove('br_container--default-state');
							container.classList.add('br_container--above');
							console.log(`Changed class: default -> above (${currentOrder} -> ${newOrder})`);
						} else if (currentOrder < 0 && newOrder > 0) {
							// Going from negative to positive: add default class, remove above
							container.classList.add('br_container--default-state');
							container.classList.remove('br_container--above');
							console.log(`Changed class: above -> default (${currentOrder} -> ${newOrder})`);
						}
						
						console.log(`Changed order: ${currentOrder} -> ${newOrder}`);
					});
				};
				
				// Make it very clear buttons are active
				decrementBtn.style.cursor = 'pointer';
				incrementBtn.style.cursor = 'pointer';
				
				console.log("Button handlers added");
				
				// Navigation menu handlers
				const navHome = document.getElementById('nav-home');
				const navProjects = document.getElementById('nav-projects');
				const navContact = document.getElementById('nav-contact');
				const navExplanation = document.getElementById('nav-explanation');
				
				// Navigate to specific views using the increment/decrement logic
				function navigateToView(targetBaseOrder) {
					// Get current state
					const containers = document.querySelectorAll('.br_container');
					
					// 1. Find the current base order (the smallest order value)
					let currentBaseOrder = Number.MAX_SAFE_INTEGER;
					containers.forEach(container => {
						const orderVal = parseInt(container.style.getPropertyValue('--order') || '1');
						if (orderVal < currentBaseOrder) {
							currentBaseOrder = orderVal;
						}
					});
					
					// 2. Calculate how many steps to increment or decrement
					// Skip zero in calculations
					let stepsToMove = targetBaseOrder - currentBaseOrder;
					if (currentBaseOrder < 0 && targetBaseOrder > 0) {
						// When crossing from negative to positive, account for skipping zero
						stepsToMove -= 1;
					} else if (currentBaseOrder > 0 && targetBaseOrder < 0) {
						// When crossing from positive to negative, account for skipping zero
						stepsToMove += 1;
					}
					
					console.log(`Current base: ${currentBaseOrder}, Target: ${targetBaseOrder}, Steps: ${stepsToMove}`);
					
					// 3. Execute the required steps
					if (stepsToMove < 0) {
						// Need to decrement
						for (let i = 0; i > stepsToMove; i--) {
							decrementAllContainers();
						}
					} else if (stepsToMove > 0) {
						// Need to increment
						for (let i = 0; i < stepsToMove; i++) {
							incrementAllContainers();
						}
					}
				}
				
				// Increment all containers (reusing existing logic)
				function incrementAllContainers() {
					const containers = document.querySelectorAll('.br_container');
					const maxBlocks = containers.length;
					
					// Check if any container is already at the maximum limit
					let atMaximumLimit = false;
					containers.forEach(container => {
						const orderValue = container.style.getPropertyValue('--order');
						if (orderValue && parseInt(orderValue) === maxBlocks) {
							atMaximumLimit = true;
						}
					});
					
					// If at limit, show message and stop
					if (atMaximumLimit) {
						console.log(`Cannot increment: A container is already at maximum value (${maxBlocks})`);
						return;
					}
					
					// Process all containers
					containers.forEach(container => {
						let order = container.style.getPropertyValue('--order');
						if (!order) {
							order = container.getAttribute('data-order') || '1';
						}
						
						let currentOrder = parseInt(order);
						
						// Skip zero when incrementing
						let newOrder;
						if (currentOrder === -1) {
							newOrder = 1; // Skip zero
						} else {
							newOrder = currentOrder + 1;
						}
						
						// Update order and classes
						container.style.setProperty('--order', newOrder);
						
						// Update classes based on sign change
						if (currentOrder < 0 && newOrder > 0) {
							container.classList.add('br_container--default-state');
							container.classList.remove('br_container--above');
						}
					});
				}
				
				// Decrement all containers (reusing existing logic)
				function decrementAllContainers() {
					const containers = document.querySelectorAll('.br_container');
					const maxBlocks = containers.length;
					
					// Define minimum limit (one less than max blocks)
					const minLimit = -(maxBlocks - 1);
					
					// Check if any container is already at the minimum limit
					let atMinimumLimit = false;
					containers.forEach(container => {
						const orderValue = container.style.getPropertyValue('--order');
						if (orderValue && parseInt(orderValue) === minLimit) {
							atMinimumLimit = true;
						}
					});
					
					// If at limit, show message and stop
					if (atMinimumLimit) {
						console.log(`Cannot decrement: A container is already at minimum value (${minLimit})`);
						return;
					}
					
					// Process all containers
					containers.forEach(container => {
						let order = container.style.getPropertyValue('--order');
						if (!order) {
							order = container.getAttribute('data-order') || '1';
						}
						
						let currentOrder = parseInt(order);
						
						// Skip zero when decrementing
						let newOrder;
						if (currentOrder === 1) {
							newOrder = -1; // Skip zero
						} else {
							newOrder = currentOrder - 1;
						}
						
						// Update order and classes
						container.style.setProperty('--order', newOrder);
						
						// Update classes based on sign change
						if (currentOrder > 0 && newOrder < 0) {
							container.classList.remove('br_container--default-state');
							container.classList.add('br_container--above');
						}
					});
				}
				
				// Add click handlers to navigation items
				navHome.addEventListener('click', (e) => {
					e.preventDefault();
					console.log("Setting Home view (orders 1 to 8)");
					navigateToView(1); // Home: orders 1 to 8
				});
				
				navProjects.addEventListener('click', (e) => {
					e.preventDefault();
					console.log("Setting Projects view (orders -1 to 7)");
					navigateToView(-1); // Projects: orders -1 to 7
				});
				
				navContact.addEventListener('click', (e) => {
					e.preventDefault();
					console.log("Setting Contact view (orders -6 to 2)");
					navigateToView(-6); // Contact: orders -6 to 2
				});
				
				navExplanation.addEventListener('click', (e) => {
					e.preventDefault();
					console.log("Setting Explanation view (orders -7 to 1)");
					navigateToView(-7); // Explanation: orders -7 to 1
				});
			});
		</script>
	</body>
</html>
